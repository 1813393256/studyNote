# java

## 浅拷贝与深拷贝

**浅拷贝** 对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。 

**深拷贝** 对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。 

## 排序

>| 冒泡排序 | O(n2)     |
>| -------- | --------- |
>| 选择排序 | O(n2)     |
>| 插入排序 | O(n2)     |
>| 希尔排序 | O(n1.5)   |
>| 快速排序 | O(N*logN) |
>| 归并排序 | O(N*logN) |
>| 堆排序   | O(N*logN) |
>| 基数排序 | O(d(n+r)) |

## 线程

### 线程状态

线程的创建方式：实现Runnable接口，继承Thread类，实现Callable接口（有返回值，可以抛出异常，实现call()

> 推荐使用Runnable接口与Callable接口的使用方式(动态监控,可以调用FutureTask.cancle())，避免java单继承的局限性,线程池的execute()方法值接收Runbale类型(子类型亦可，向上造型)，FutureTask.get()方法会阻塞主线程.

#### 线程阻塞

1. 调用sleep方法，
2. 阻塞式IO方法（例如：读取一个文件）,
3. suspend方法（易造成死锁，不建议调用）

#### 线程死亡

线程结束即为死亡，

1. run(),call()方法执行完成，
2. 线程抛出一个未捕获异常或错误，
3. 调用stop()方法结束该线程(易造成死锁，持有锁但却停止了本线程，其他线程还在等待锁)

### 线程安全

单线程运行结果与多线程运行结果一致即为线程安全，反之即为线程不安全。

> 线程安全问题由全局变量及静态变量引起的
>
> 解决数据不一致或数据污染问题

#### 线程安全-解决

1. 同步代码块（synchronized）

2. 同步方法（synchronized）

3. 同步锁（ReentrantLock）

4. 特殊域变量（volatile）

5. 局部变量（ThreadLock）

6. 阻塞队列（LinkedBlockingQueue）

7. 原子变量（Atomic*）


#### synchronized与Lock的区别

1. synchronized是java内置关键字，Lock是个java类
2. synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁
3. Lock需要在finally中手动释放锁，否则容易造成死锁
4. 用synchronized锁，某个线程在执行同步代码块期间阻塞，另一个线程得不到锁会一直等待。而Lock锁会自动结束等待
5. synchronized的锁可重入、不可中断、非公平；Lock锁可重入、可判断、可公平
6. Lock锁适合大量同步的代码的同步问题，synchronized锁适合少量代码的同步问题

### 线程死锁

#### 什么是死锁？

多个线程竞争资源而造成的一种相互等待的情况，这些进程都无法向前推进。

#### 死锁产生的必要条件

满足四个必要条件将会发生死锁。系统发生死锁，四个条件必定成立，某个条件不满足，就不会发生死锁。

1. **互斥条件：**一段时间内某资源仅为一个进程占有，若其他进程请求该资源，则请求进程只能等待。
2. **不可剥夺条件：**进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放。
3. **请求与保持条件：**进程已经保持可至少一个资源，但又提出获得新资源的请求，而该资源已被其他进程占有，此时请求进程被阻塞，但自己已获得的资源保持不放。
4. **循环等待条件：**A进程需要B进程已得到的资源，B进程需要A进程已得到的资源。

#### 死锁处理

1. **预防死锁：**通过设置某些限制条件，破坏产生死锁的四个必要条件中的一个或几个条件，来防止死锁的发生

   1. 破坏互斥条件

      >"互斥"条件是无法破坏的

   2. 破坏占有并等待条件

      >系统中不允许进程在已获得某种资源的情况下，申请其他资源，即阻止进程在持有资源的同时申请其他资源

      1. 一次性分配资源，即创建进程时，要求它申请所需的全部资源，系统或满足其所有要求，或什么也不给它
      2. 要求每个进程提出新的资源申请前，释放它所占有的资源。

   3. 破坏不可抢占条件

      > 运行对资源实行抢夺

      1. 如果占有某些资源的一个进程进行进一步资源请求被拒绝，则该进程必须释放它最初占有的资源，如果有必要，可以再次请求这些资源和另外的资源
      2. 如果一个进程请求当前被另一个进程占有的一个资源，则操作系统可以抢占另一个进程，要求它释放资源。只有在任意两个进程的优先级都不相同的条件下，才能预防死锁

   4. 破坏循环等待条件

      > 将系统中的所有资源统一编号，进程可在任何时刻提出资源申请，但所有申请必须按照资源的编号顺序（升序）提出。这样就能保证系统不出现死锁

2. **避免死锁：**在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免死锁的发生。

   > 不严格限制产生死锁的必要条件的存在，因为即使死锁的必要条件存在，也不一定发生死锁

   1. 有序资源分配法

      1. 必须为所有资源统一编号，例如：打印机为1，传真机为2，磁盘为3等

      2. 同类资源必须一次申请完，例如：打印机和传真机，申请了打印机时，必须同时申请传真机

      3. 不同类资源必须按顺序申请

         ```
         线程A，B申请打印机和传真机时都必须按先申请打印机再申请传真机的顺序进行申请。
         ```

   2. 银行家算法

   3. 顺序加锁

   4. 限时加锁

      ```
      线程尝试获取锁的时候加一个超时时间，若超过这个时间则放弃对该锁请求，并回退并释放所有已获得的锁，然后等待一段随机的时间再重试
      ```

      1. 当线程数量少时，该种方式可避免死锁，但当线程数量过多时，这些线程的加锁时限相同的概率就高很多，可能会导致超时后重试的死循环
      2. java中不能对synchronized同步块设置超时时间。需要创建一个自定义锁，或使用java5中java.util.concurent包下的工具类

3. **检测死锁：**允许系统在运行过程中发生死锁，但可设置检测机构及时检测死锁的发生，并采取适当措施加以清除

4. **解除死锁：**当检测出死锁后，便采取适当的措施将进程从死锁状态中解脱出来

#### 死锁恢复

1. 利用抢占恢复

   > 临时将某个资源从它的当前所属进程转移到另一个进程。
   >
   > 很可能需要人工干预，主要做法是否可行需要取决于资源本身的特性

2. 利用回滚恢复

   > 周期性的将进程的状态备份，当发现进程死锁后，根据备份将该进程复位到一个更早的，还没取得所需的资源的状态，接着就把这些资源分配给其他死锁进程

3. 通过杀死进程恢复（最不推荐使用）

   > 最简单的方式就是杀死一个或若干个进程
   >
   > 尽可能保证杀死的进程可以从头再来而不带来副作用

### 线程通讯

#### 为什么要线程通信？

多个线程并发执行时，在默认情况下cpu是随机切换线程的，有时我们希望cpu按我们的规律执行线程，此时就需要线程之间协调通信。

#### 线程通讯方式

**线程间通信常用方式如下：**

1. 休眠唤醒方式：
   1. Object的wait、notify、notifyAll
   2. Condition的await、signal、signalAll
2. CountDownLatch:用于某个线程A等待若干个其他线程执行完之后，他才执行
3. CyclicBarrier:一组线程等待至某个状态之后再全部同时执行。底层由ReentrantLock和Condition实现
4. Semaphore：用于控制对某组资源的访问权限。acquire()等待获取资源，release()释放资源

**Object和Condition休眠唤醒区别**

1. Object wait()必须在synchronized(同步锁)下使用
2. Object wait()必须要通过notify()方法进行唤醒
3. Condition await()必须和Lock(互斥锁/共享锁)配合使用
4. Condition await()必须通过singnal()方法进行唤醒

# 设计模式

## 设计模式的六大原则

### 开闭原则

> 对扩展开放，对修改关闭

### 里氏代换原则

> 任何基类可以出现的地方，子类一定可以出现。对实现抽象化的具体步骤的规范

### 依赖倒转原则

> 针对接口编程，依赖于抽象而不依赖于具体

### 接口隔离原则

> 使用多个隔离的接口，比使用单个接口要好，降低类之间的耦合度

### 迪米特法则，又称最少知道原则

> 一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立

### 合成复用原则

> 尽量使用合成/聚合的方式，而不是使用继承

## 创建型模式

> 创建对象的同时隐藏创建逻辑

### 工厂模式

> 主要解决接口选择的问题 
>
> **应用：** 您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 ![]( https://www.runoob.com/wp-content/uploads/2014/08/AB6B814A-0B09-4863-93D6-1E22D6B07FF8.jpg )

### 抽象工厂模式

> 主要解决接口选择的问题 
>
> **应用：** QQ 换皮肤，一整套一起换。 
>
> ![]( https://www.runoob.com/wp-content/uploads/2014/08/3E13CDD1-2CD2-4C66-BD33-DECBF172AE03.jpg )

### 单例模式

> 一个全局使用的类频繁地创建与销毁 
>
> **应用：** 一个班级只有一个班主任 
>
> ![]( https://www.runoob.com/wp-content/uploads/2014/08/62576915-36E0-4B67-B078-704699CA980A.jpg )

### 建造者模式

>解决套餐点餐问题，不同的食物组合会生成不同的套餐
>
>**应用：**  1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的"套餐"。 2、JAVA 中的 StringBuilder。 
>
>![]( https://www.runoob.com/wp-content/uploads/2014/08/builder_pattern_uml_diagram.jpg )

### 原型模式

> 在运行期建立和删除原型 
> **应用：** 1、细胞分裂。 2、JAVA 中的 Object clone() 方法
>
> ![](  https://www.runoob.com/wp-content/uploads/2014/08/prototype_pattern_uml_diagram.jpg )

## 结构型模式

### 适配器模式

> 解决接口不兼容问题
>
> ![](https://www.runoob.com/wp-content/uploads/2014/08/adapter_pattern_uml_diagram.jpg )

 

### 桥接模式

> 在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活 
>
>**应用：** 1、对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统。2、 一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。 
>
>![]( https://www.runoob.com/wp-content/uploads/2014/08/bridge_pattern_uml_diagram.jpg )

### 过滤器模式

### 组合模式

### 装饰者模式

### 外观模式

### 享元模式

### 代理模式

## 行为型模式

### 责任链模式

### 命令模式

### 解释器模式

### 迭代模式

### 中介者模式

### 备忘录模式

### 观察者模式

### 状态模式

### 空对象模式

### 策略模式

### 模板模式

### 访问者模式

## J2EE模式

### MVC模式

### 业务代表模式

### 组合实体模式

### 数据访问对象模式

### 前端控制器模式

### 拦截过滤器模式

### 服务定位模式

### 传输对象模式



