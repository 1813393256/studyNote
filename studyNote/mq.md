# MQ(消息中间件)

## MQ的产品种类

1. Kafka
2. RabbitMQ
3. RocketMQ
4. ActiveMQ
5. 其他

## MQ之ActiveMQ

1. api发送和接收
2. MQ的高可用性
3. MQ的集群和容错配置
4. MQ的持久化
5. 延时发送/定时投递
6. 签收机制
7. spring整合
8. 其他

## MQ能干嘛

1. 解耦：当新的板块接进来时，可以做到代码改动最小
2. 削峰：设置流量缓存池，可以让后端系统按照自身吞吐能力进行消费，不被冲垮
3. 异步：强弱依赖梳理能够将非关键调用链路的操作异步化并提升整体系统的吞吐能力
4. 消息之间要异步，系统之间要解耦

## 面向消息的中间件MOM

1. 利用高效可靠的消息传递机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传递与消息排队模型在分布式环境下提供应用解耦、弹性伸缩、沉余存储、流量削峰、异步通信、数据同步等功能。
2. 发送者将消息发送给服务器，消息服务器将消息存放在若干个队列/主题topic中，在合适的时候，消息服务器会将消息转发给接受者。在这个过程中，发送和接收是异步的，即发送无需等待，而且发送者和接收者的生命周期也没有必然关系；尤其在发布pub/订阅sub模式下，也可以完成一对多的通信，即让一个消息有多个接收者。

## Linux安装ActiveMQ

activemq的默认进程端口是61616

1. ps -ef|grep activemq|grep -v grep
2. netstat -anp|grep 61616
3. lsof -i:61616

## win访问linux中的mq

1. 关闭linux防火墙:service iptables stop
2. 关闭windows防火墙
3. linux中:
   1. 查看ip：ifconfig
   2. ping ip(windos地址)
4. windwos中：
   1. 查看ip：ipconfig
   2. ping ip(linux地址)
5. win中浏览器通过地址ip:8161可以访问activemq页面，默认用户名和密码为admin

## JMS开发的基本步骤

1. 创建一个connection factory
2. 通过connection factory创建JMS connection
3. 启动JMS connection
4. 通过connection创建JMS session
5. 创建JMS destination
6. 创建JMSproducer或者创建JMS message并设置destination
7. 创建JMS consumer或者注册一个JMS message listener
8. 发送或者接收JMS message(s)
9. 关闭所有的JMS资源(connection，session,producer,consumer等)

## 点对点消息传递域特点：

1. 每个消息只能有一个消费者，属于1:1的关系
2. 消息的生产者和消费者之间没有时间上的相关性
3. 消息被消费后队列中不会再存储，所以消费者不会消费到已经被消费掉的消息

## 发布/订阅消息传递域的特点

1. 生产者将消息发布到topic中，每个消息可以有多个消费者，属于1:N的关系
2. 生产者和消费者之间有时间上的相关性。订阅某一个主题的消费者只能消费自它订阅之后发布的消息
3. 生产者生产时，topic不保存消息它是无状态的不落地，假如无人订阅就去生产，那就是一条废消息，所有，一般先启动消费者再启动生产者。
4. JMS规范允许客户创建持久订阅，这在一定程度上放松了时间上的相关性要求。持久订阅允许消费者消费它在未处于激活状态时发送的消息。如：微信公众号订阅。

## Topic模式队列和Queue模式队列的区别

**Topic**：

1. 订阅-发布模式，如果当前没有订阅者，消息将会被丢弃，如果有多个订阅者，那么这些订阅者都会接收消息
2. 无状态
3. 消息按照订阅订阅者的数量进行复制，所有处理性能会随着订阅者的增加而明显降低，并且还要结合不同消息协议自身的性能差异

**Queue：**

1. 负载均衡模式，如果当前没有消费者，消息也不会丢弃；如果有多个消费者，那么一条消息也只会发送给其中一个消费者，并且要求消费者ack消息
2. Queue数据默认会在mq服务器上以文件形式保存，比如Active MQ一般保存在$AMQ_HOME\data\kr-store\data下面，也可以配置成DB存储
3. 由于一条消息只发送给一个消费者，所以就算消费者再多，性能也不会有明显降低，当然不同消息协议的具体性能也是有差异的

# JMS