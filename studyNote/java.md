# java

## JAVAEE

JavaEE是一套使用java进行企业级应用开发的大家一致遵循的13个核心规范工业标准。JavaEE平台提供了一个基于组件的方法来加快设计、开发、装配及部署企业应用程序。

1. JDBC(Java Database)数据库连接
2. JNDI(Java Naming and Directory Interfaces)Java的命名和目录接口
3. EJB(Enterprise JavaBean)
4. RMI(Remote Method Invoke)远程方法调用
5. Java IDL(Interface Description Language)/CORBA(Common Object Broker Architecture)接口定义语言/公用对象请求代理程序体系结构
6. JSP(Java Server Pages)
7. Servlet
8. XML(Extensible Markup Language)可扩展标记语言
9. JMS(Java Message Service)Java消息服务
10. JTA(Java Transaction API)Java事务API
11. JTS(Java Transaction Service)Java事务服务
12. JavaMail
13. JAF(JavaBean Activation Framework)

## 浅拷贝与深拷贝

**浅拷贝** 对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。 

**深拷贝** 对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。 

## 排序

>| 冒泡排序 | O(n2)     |
>| -------- | --------- |
>| 选择排序 | O(n2)     |
>| 插入排序 | O(n2)     |
>| 希尔排序 | O(n1.5)   |
>| 快速排序 | O(N*logN) |
>| 归并排序 | O(N*logN) |
>| 堆排序   | O(N*logN) |
>| 基数排序 | O(d(n+r)) |

## 线程

### 线程状态

线程的创建方式：实现Runnable接口，继承Thread类，实现Callable接口（有返回值，可以抛出异常，实现call()

> 推荐使用Runnable接口与Callable接口的使用方式(动态监控,可以调用FutureTask.cancle())，避免java单继承的局限性,线程池的execute()方法值接收Runbale类型(子类型亦可，向上造型)，FutureTask.get()方法会阻塞主线程.

#### 线程阻塞

1. 调用sleep方法，
2. 阻塞式IO方法（例如：读取一个文件）,
3. suspend方法（易造成死锁，不建议调用）

#### 线程死亡

线程结束即为死亡，

1. run(),call()方法执行完成，
2. 线程抛出一个未捕获异常或错误，
3. 调用stop()方法结束该线程(易造成死锁，持有锁但却停止了本线程，其他线程还在等待锁)

### 线程安全

单线程运行结果与多线程运行结果一致即为线程安全，反之即为线程不安全。

> 线程安全问题由全局变量及静态变量引起的
>
> 解决数据不一致或数据污染问题

#### 线程安全-解决

1. 同步代码块（synchronized）

2. 同步方法（synchronized）

3. 同步锁（ReentrantLock）

4. 特殊域变量（volatile）

5. 局部变量（ThreadLock）

6. 阻塞队列（LinkedBlockingQueue）

7. 原子变量（Atomic*）


#### synchronized与Lock的区别

1. synchronized是java内置关键字，Lock是个java类
2. synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁
3. Lock需要在finally中手动释放锁，否则容易造成死锁
4. 用synchronized锁，某个线程在执行同步代码块期间阻塞，另一个线程得不到锁会一直等待。而Lock锁会自动结束等待
5. synchronized的锁可重入、不可中断、非公平；Lock锁可重入、可判断、可公平
6. Lock锁适合大量同步的代码的同步问题，synchronized锁适合少量代码的同步问题

### 线程死锁

#### 什么是死锁？

多个线程竞争资源而造成的一种相互等待的情况，这些进程都无法向前推进。

#### 死锁产生的必要条件

满足四个必要条件将会发生死锁。系统发生死锁，四个条件必定成立，某个条件不满足，就不会发生死锁。

1. **互斥条件：**一段时间内某资源仅为一个进程占有，若其他进程请求该资源，则请求进程只能等待。
2. **不可剥夺条件：**进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放。
3. **请求与保持条件：**进程已经保持可至少一个资源，但又提出获得新资源的请求，而该资源已被其他进程占有，此时请求进程被阻塞，但自己已获得的资源保持不放。
4. **循环等待条件：**A进程需要B进程已得到的资源，B进程需要A进程已得到的资源。

#### 死锁处理

1. **预防死锁：**通过设置某些限制条件，破坏产生死锁的四个必要条件中的一个或几个条件，来防止死锁的发生

   1. 破坏互斥条件

      >"互斥"条件是无法破坏的

   2. 破坏占有并等待条件

      >系统中不允许进程在已获得某种资源的情况下，申请其他资源，即阻止进程在持有资源的同时申请其他资源

      1. 一次性分配资源，即创建进程时，要求它申请所需的全部资源，系统或满足其所有要求，或什么也不给它
      2. 要求每个进程提出新的资源申请前，释放它所占有的资源。

   3. 破坏不可抢占条件

      > 运行对资源实行抢夺

      1. 如果占有某些资源的一个进程进行进一步资源请求被拒绝，则该进程必须释放它最初占有的资源，如果有必要，可以再次请求这些资源和另外的资源
      2. 如果一个进程请求当前被另一个进程占有的一个资源，则操作系统可以抢占另一个进程，要求它释放资源。只有在任意两个进程的优先级都不相同的条件下，才能预防死锁

   4. 破坏循环等待条件

      > 将系统中的所有资源统一编号，进程可在任何时刻提出资源申请，但所有申请必须按照资源的编号顺序（升序）提出。这样就能保证系统不出现死锁

2. **避免死锁：**在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免死锁的发生。

   > 不严格限制产生死锁的必要条件的存在，因为即使死锁的必要条件存在，也不一定发生死锁

   1. 有序资源分配法

      1. 必须为所有资源统一编号，例如：打印机为1，传真机为2，磁盘为3等

      2. 同类资源必须一次申请完，例如：打印机和传真机，申请了打印机时，必须同时申请传真机

      3. 不同类资源必须按顺序申请

         ```
         线程A，B申请打印机和传真机时都必须按先申请打印机再申请传真机的顺序进行申请。
         ```

   2. 银行家算法

   3. 顺序加锁

   4. 限时加锁

      ```
      线程尝试获取锁的时候加一个超时时间，若超过这个时间则放弃对该锁请求，并回退并释放所有已获得的锁，然后等待一段随机的时间再重试
      ```

      1. 当线程数量少时，该种方式可避免死锁，但当线程数量过多时，这些线程的加锁时限相同的概率就高很多，可能会导致超时后重试的死循环
      2. java中不能对synchronized同步块设置超时时间。需要创建一个自定义锁，或使用java5中java.util.concurent包下的工具类

3. **检测死锁：**允许系统在运行过程中发生死锁，但可设置检测机构及时检测死锁的发生，并采取适当措施加以清除

4. **解除死锁：**当检测出死锁后，便采取适当的措施将进程从死锁状态中解脱出来

#### 死锁恢复

1. 利用抢占恢复

   > 临时将某个资源从它的当前所属进程转移到另一个进程。
   >
   > 很可能需要人工干预，主要做法是否可行需要取决于资源本身的特性

2. 利用回滚恢复

   > 周期性的将进程的状态备份，当发现进程死锁后，根据备份将该进程复位到一个更早的，还没取得所需的资源的状态，接着就把这些资源分配给其他死锁进程

3. 通过杀死进程恢复（最不推荐使用）

   > 最简单的方式就是杀死一个或若干个进程
   >
   > 尽可能保证杀死的进程可以从头再来而不带来副作用

### 线程通讯

#### 为什么要线程通信？

多个线程并发执行时，在默认情况下cpu是随机切换线程的，有时我们希望cpu按我们的规律执行线程，此时就需要线程之间协调通信。

#### 线程通讯方式

**线程间通信常用方式如下：**

1. 休眠唤醒方式：
   1. Object的wait、notify、notifyAll
   2. Condition的await、signal、signalAll
2. CountDownLatch:用于某个线程A等待若干个其他线程执行完之后，他才执行
3. CyclicBarrier:一组线程等待至某个状态之后再全部同时执行。底层由ReentrantLock和Condition实现
4. Semaphore：用于控制对某组资源的访问权限。acquire()等待获取资源，release()释放资源

**Object和Condition休眠唤醒区别**

1. Object wait()必须在synchronized(同步锁)下使用
2. Object wait()必须要通过notify()方法进行唤醒
3. Condition await()必须和Lock(互斥锁/共享锁)配合使用
4. Condition await()必须通过singnal()方法进行唤醒

**CountDownLatch方式**

1. CountDownLatch存在于java.util.concurrent下
2. CountDownLatch能是一个线程等待其他线程完成各自的工作后执行
3. CountDownLatch是通过一个计数器来实现的，计数器的初始值为线程的数量

**CyclicBarrier方式**

1. CyclicBarrier存在于java.util.concurrent包下
2. CyclicBarrier实现让一组线程等待至某个状态之后再全部同时执行
3. CyclicBarrier底层是基于ReentrantLock和Condition实现

**Semaphore方式**

1. Semaphore存在于java.util.concurrent包下
2. Semaphore用于控制对某组资源的访问权限

### 小结

#### sleep和wait区别

1. wait只能在同步上下文中调用，否则或抛出非法监视器状态异常（IllegalMonitorStateException）
2. sleep方法则不需要在同步方法或同步块中调用
3. wait方法定义在Object类中，作用于对象本身，sleep方法定义在java.lang.Thread中，作用于当前线程
4. wait会释放资源，sleep不会释放资源
5. wait方法通过其他线程调用notify()或notifyAll()方法进行唤醒。
6. sleep()方法通过超时或者调用interrupt()方法进行唤醒。
7. wait是实例方法，sleep是静态方法

#### wait和notify区别

1. wait和notify都是object中的方法
2. wait和notify执行前线程都必须获得对象锁
3. wait的作用是使当前线程进行等待
4. notify的作用是通知其他等待当前线程的对象锁的线程执行

## Java内存模型

jvm:虚拟机栈，堆，方法区，程序计数器，本地方法栈

### PC程序计数器

1. 每个线程对应一个程序计数器
2. 各线程的程序计数器是线程私有的，互不影响，是线程安全的
3. 程序计数器记录线程正在执行的内存地址，以便被中断线程恢复执行时再次按照中断的指令地址继续执行

### JVM Stack

1. 每个线程会对应一个java栈
2. 每个java栈由若干栈帧组成
3. 每个方法对应一个栈帧
4. 栈帧在方法运行时，创建并入栈，方法执行完，该栈帧中的元素作为该方法返回值，该栈帧被清除
5. 栈顶的栈帧叫活动栈，表示当前执行的方法，才可以被cpu执行
6. 线程请求的栈深度大于虚拟机所允许的深度，将抛出栈溢出错误
7. 栈扩展时无法申请到足够的内存，就会抛出内存溢出错误

### 方法区MethodArea

1. 方法区时java堆的永久区(PermanetGeneration)
2. 方法区存放了要加载的类的信息(名称、修饰符等)、类中的静态常量、类中定义为final类型的常量、类中的Field信息、类中的方法信息
3. 方法区是被java线程共享的
4. 方法区要使用的内存超过其允许的大小时，会抛出OutOfMemoryError:PremGen space的错误信息

### 常量池Constant Pool

1. 常量池是方法区的一部分

2. 常量池中存储两类数据:字面量和引用量

   字面量：字符串、final变量等

   引用量：类/接口、方法和字段的名称和描述

3. 常量池在编译期间就被确定，并保存在已编译的.class文件中

   

### JVM执行流程

1. 类加载器将java代码加载到方法区
2. 执行引擎从方法区找到main方法
3. 为方法创建栈帧放入方法栈，同时创建该栈帧的程序计数器
4. 执行引擎请求CPU执行该方法
5. CPU将方法栈数据加载到工作内存(寄存器和高速缓存)，执行该方法
6. CPU执行完之后将执行结果从工作内存同步到主内存

## 多线程

### 多线程特性

多线程编程要满足三个特性：原子性，可见性，有序性

1. 原子性：一个操作或多个操作要么全部执行并且执行的过程不会被任何因素打断，要么都不执行
2. 可见性：多个线程访问同一变量时，一个线程修改了该变量的值，其他线程能立即看到修改的值
3. 有序性：程序执行的顺序按照代码的先后顺序执行

### 多线程控制类

为保证多线程的三个特性，java引入了很多线程控制机制：

1. ThreadLocal:线程本地变量
2. 原子类：保证变量原子操作
3. Lock类：保证线程有序性
4. Volatile关键字：保证线程变量可见性

### ThreadLocal

1. **作用：**提供线程局部变量，即为使用相同变量的每一个线程维护一个该变量的副本。当某些数据是以线程为作用域并且不同线程具有不同的数据副本时，就可考虑使用。如：数据库连接Connection，每个请求处理线程都需要，但又不相互影响，就使用ThreadLocal实现。
2. **常用方法：**
   1. initialValue:副本创建方法
   2. get：获取副本方法
   3. set：设置副本方法

### 原子类

java.util.concurrent.atomic包，解决基本类型操作的非原子性导致在多线程并发情况下引发的问题

1. 原子更新基本类型：AtomicInteger、AtomicBoolean、AtomicLong
2. 原子更新数组类型：AtomicIntegerArray、AtomicLongArray
3. 原子更新引用类型：AtomicReference、AtomicStampedReference等
4. 原子更新属性类型：AtomicIntegerFieldUpdater、AtomicLongFieldUpdater

CAS(CompareAndSwap)的ABA问题**

1. **ABA问题：**一个线程把数据A变为了B，然后又重新变成了A。此时另外一个线程读取的时候，发现A没有变化，就误以为是原来的那个A。
2. **解决ABA问题：**使用AtomicStampedReference
   1. AtomicStampedReference(初始值，时间戳)：构造函数设置初始值和初始时间
   2. getStamp：获取时间戳
   3. getReference：获取预期值
   4. compareAndSet(预期值，预期时间戳，更新时间戳):实现CAS时间戳和预期值的比对

### Lock类

#### 可重入锁

可重复获取相同的锁而不会出现死锁现象，synchronized和ReentrantLock都是可重入锁